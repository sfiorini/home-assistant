<script src="bower_components/moment/moment.js"></script>
<link rel="import" href="bower_components/polymer/polymer.html">
<link rel="import" href="bower_components/core-tooltip/core-tooltip.html">
<link rel="import" href="bower_components/paper-button/paper-button.html">
<link rel="import" href="bower_components/paper-toggle-button/paper-toggle-button.html">

<link rel="import" href="state-badge.html">

<polymer-element name="state-card"
  attributes="entity state last_changed state_attr cb_turn_on, cb_turn_off cb_edit">
  <template>
    <style>
    :host {
      background-color: #fff;
      border-radius: 2px;
      box-shadow: rgba(0, 0, 0, 0.098) 0px 2px 4px, rgba(0, 0, 0, 0.098) 0px 0px 3px;
      /* transition */
      -webkit-transition: all 0.30s ease-out;
      transition: all 0.30s ease-out;

      position: relative;
      background-color: white;
      padding: 15px;
      width: 100%;
    }

    state-badge {
      float: left;
      cursor: pointer;
      transition: background-color .2s ease-in-out, color .5s ease-in-out;
    }

    state-badge:hover {
      background-color: #039be5;
    }

    /* Color the icon if light or sun is on */
    state-badge[data-domain=light][data-state=on],
    state-badge[data-domain=sun][data-state=above_horizon] {
      color: #fff176;
    }

    .name, .state.text {
      text-transform: capitalize;  
      font-weight: 300;
      font-size: 1.3rem;
    }

    .state {
      text-align: right;
    }

    .info {
      margin-left: 60px;
    }

    .time-ago {
      color: darkgrey;
      margin-top: -2px;
    }

    /* the splash while enabling */
    paper-toggle-button::shadow paper-radio-button::shadow #ink[checked] {
      color: #0091ea;
    }

    /* filling of circle when checked */
    paper-toggle-button::shadow paper-radio-button::shadow #onRadio {
      background-color: #039be5;
    }

    /* line when checked */
    paper-toggle-button::shadow #toggleBar[checked] {
      background-color: #039be5;
    }    
    </style>

    <div horizontal justified layout>
      
      <div class="entity">
        <state-badge
          id="badge" 
          domain="{{domain}}"
          state="{{state}}"
          data-domain="{{domain}}"
          data-state="{{state}}"
          on-click="{{editClicked}}">
        </state-badge>

        <div class='info'>
          <div class='name'>
            <template if="{{state_attr['friendly_name']}}">{{state_attr['friendly_name']}}</template>
            <template if="{{!state_attr['friendly_name']}}">{{entity_id | makeReadable}}</template>
          </div>

          <div class="time-ago">
            <core-tooltip label="{{last_changed}}" position="bottom">
              {{last_changed_from_now}}
            </core-tooltip>
          </div>
          
        </div>
      </div>

      <template if="{{!state_unknown}}">
        <template if="{{state == 'on' || state == 'off'}}">
          <div class='state toggle' self-center flex>
            <paper-toggle-button checked="{{toggleChecked}}">
            </paper-toggle-button>
          </div>
        </template>
        <template if="{{state != 'on' && state != 'off'}}">
          <div class='state text'>
            {{state | makeReadable}}
          </div>
        </template>
      </template>

      <template if="{{state_unknown}}">
        <div class="state" self-center flex>Updating..</div>
      </template>

    </div>    

  </template>
  <script>
  Polymer({
    // attributes
    entity: "",
    state: "",
    last_changed: "never",
    state_attr: {},
    cb_turn_on: null,
    cb_turn_off: null,
    cb_edit: null,
    state_unknown: false,
    toggleChecked: -1,

    computed: {
      domain: "entity | parseDomain",
      entity_id: "entity | parseEntityId",
      last_changed_from_now: "last_changed | parseLastChangedFromNow"
    },

    parseDomain: function(entity) {
      return entity.split('.')[0];
    },

    parseEntityId: function(entity) {
      return entity.split('.')[1];
    },

    parseLastChangedFromNow: function(lastChanged) {
      return moment(lastChanged, "HH:mm:ss DD-MM-YYYY").fromNow()
    },

    toggleCheckedChanged: function(oldVal, newVal) {
      // to filter out init
      if(oldVal === -1) {
        return;
      }

      if(newVal && this.state == "off") {
        this.turn_on();
      } else if(!newVal && this.state == "on") {
        this.turn_off();
      }
    },

    stateChanged: function(oldVal, newVal) {
      this.state_unknown = newVal == null;
      this.toggleChecked = newVal == "on"

      // for domain light, set color of icon to light color if available
      if(this.domain == "light" && newVal == "on" &&
         this.state_attr.brightness && this.state_attr.xy_color) {

        var rgb = this.xyBriToRgb(this.state_attr.xy_color[0],
                                  this.state_attr.xy_color[1],
                                  this.state_attr.brightness);
        this.$.badge.style.color = "rgb(" + rgb.map(Math.floor).join(",") + ")";
      } else {
        this.$.badge.style.color = null;
      }
    },

    turn_on: function() {
      if(this.cb_turn_on) {
        this.cb_turn_on(this.entity);

        // unset state while we wait for an update
        var delayUnsetSate = function() {
          this.state = null;
        }
        setTimeout(delayUnsetSate.bind(this), 500);      
      }
    },

    turn_off: function() {
      if(this.cb_turn_off) {
        this.cb_turn_off(this.entity);

        // unset state while we wait for an update
        var delayUnsetSate = function() {
          this.state = null;
        }
        setTimeout(delayUnsetSate.bind(this), 500);      
      }
    },

    editClicked: function() {
      if(this.cb_edit) {
        this.cb_edit(this.entity);
      }
    },

    // used as filter
    makeReadable: function(value) {
      if(typeof value == "string") {
        return value.replace(/_/g, " ");

      } else if(Array.isArray(value)) {
        return value.join(", ");

      } else {
        return value;
      }
    },

    // from http://stackoverflow.com/questions/22894498/philips-hue-convert-xy-from-api-to-hex-or-rgb
    xyBriToRgb: function (x, y, bri) {
      z = 1.0 - x - y;
      Y = bri / 255.0; // Brightness of lamp
      X = (Y / y) * x;
      Z = (Y / y) * z;
      r = X * 1.612 - Y * 0.203 - Z * 0.302;
      g = -X * 0.509 + Y * 1.412 + Z * 0.066;
      b = X * 0.026 - Y * 0.072 + Z * 0.962;
      r = r <= 0.0031308 ? 12.92 * r : (1.0 + 0.055) * Math.pow(r, (1.0 / 2.4)) - 0.055;
      g = g <= 0.0031308 ? 12.92 * g : (1.0 + 0.055) * Math.pow(g, (1.0 / 2.4)) - 0.055;
      b = b <= 0.0031308 ? 12.92 * b : (1.0 + 0.055) * Math.pow(b, (1.0 / 2.4)) - 0.055;
      maxValue = Math.max(r,g,b);
      r /= maxValue;
      g /= maxValue;
      b /= maxValue;
      r = r * 255;   if (r < 0) { r = 255 };
      g = g * 255;   if (g < 0) { g = 255 };
      b = b * 255;   if (b < 0) { b = 255 };
      return [r, g, b]
    }
  });
  </script>
</polymer-element>
